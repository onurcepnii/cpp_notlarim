SÄ±nÄ±fÄ±n elemanlarÄ± handle deÄŸilse, kaynak kontrolunu kendisi gerÃ§ekleÅŸtiren sÄ±nÄ±flarsa derleyiciye bÄ±rakabiliriz.

Not:
	Bir de copy assignment fonksiyonun idiomatic baÅŸka ÅŸekilde bir yazÄ±m biÃ§imi var. Bu yazÄ±m biÃ§imine iliÅŸkin
	idioma " Copy Swap Idiom " deniyor.

---------------------------------

//temporary objects = tipik olarak bir sÄ±nÄ±f tÃ¼rÃ¼nden nesne, fakat ortada o nesnenin isminin olmadÄ±ÄŸÄ± ifadeler.

class Nec{};

void foo(const Nec&);
void foo(Nec&&);

bÃ¶yle bir overload ile L value ve R value sÄ±nÄ±f nesneleri iÃ§in farklÄ± implementasyonlar sunuluyor.

int main()
{
Nec mynec;
	
//mynec		deÄŸiÅŸkenin ismi var. Bir ismin sÃ¶z konusu olduÄŸu ifadeler Lvalue expr, dolayÄ±sÄ±yla bu da Ã¶yle
//Nec{}		deÄŸiÅŸkenin ismi yok sÄ±nÄ±fÄ±n ismi var sadece. Ä°smin olmadÄ±ÄŸÄ± ifadeler R val. expr, dolayÄ±sÄ±yla
		bu da Ã¶yle.

		ancak bu ikiside Nec tÃ¼rÃ¼nden birer nesne.

//std::move(mynec)		l value de, r value de argÃ¼man olarak alsa, r value bir ifade oluÅŸturur.
//static_cast<Nec&&>(mynec)	pek ala bunu da kullanabiliriz, ikisi de aynÄ± iÅŸi yapmÄ±ÅŸ oluyor.

// r value expr olan sÄ±nÄ±f nesnesi oluÅŸturan birkaÃ§ tane ifade var. Birisi temporary object oluÅŸturma ifadeleri,
// ikincisi std::move() fonksiyonuna yapÄ±lan Ã§aÄŸrÄ± ifadesi, Ã¼Ã§Ã¼ncÃ¼sÃ¼ move yerine sÄ±nÄ±f tÃ¼rÃ¼nden r value ref. tÃ¼rÃ¼ne
// static_cast operatÃ¶rÃ¼ ile cast eden ifadeler.

}
	

/////////////////////////////

class Nec{};

void foo(const Nec&);		// 1
void foo(Nec&&);		// 2

Nec 	bar();
Nec&& 	baz();

int main()
{
	Nec mynec;
	
	foo(mynec);			// 1. foo Ã§aÄŸÄ±rÄ±lÄ±r.
	foo(std::move(mynec));		// 2. foo Ã§aÄŸÄ±rÄ±lÄ±r.
	foo(Nec{});			// foo'ya gÃ¶nderdiÄŸimiz ifade bir temporary object ifadesi, yani PR value
					// expression. DolayÄ±sÄ±yla R value expr. Bundan dolayÄ± 2. foo Ã§aÄŸÄ±rÄ±lÄ±r.


	foo(bar());	// R value expr. argÃ¼man vermiÅŸ olduk, 2.foo
	foo(baz());	// R value expr. argÃ¼man vermiÅŸ olduk, 2.foo

}
-gpt-
-----
bar() â†’ her Ã§aÄŸrÄ±da yeni bir Nec nesnesi oluÅŸturur.

baz() â†’ halihazÄ±rda bir yerde var olan nesneyi rvalue olarak ileri gÃ¶nderir (forward eder). Yani kendisi yeni nesne yaratmaz.

--

bar() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda yepyeni bir Nec nesnesi Ã¼retirsin.

baz() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda ise g nesnesi taÅŸÄ±nmak Ã¼zere geri dÃ¶ndÃ¼rÃ¼lÃ¼r.

ğŸ‘‰ KÄ±saca:

bar() prvalue dÃ¶ndÃ¼rÃ¼r (tamamen yeni geÃ§ici nesne).

baz() xvalue dÃ¶ndÃ¼rÃ¼r (zaten var olan nesneyi â€œÃ¶lmeye hazÄ±râ€ ÅŸekilde geri verir).
-----


* 2.foo'yu silersek kodda sentaks hatasÄ± olmaz, hepsi 1.foo'ya baÄŸlanÄ±r. Ã‡Ã¼nkÃ¼ const l value referans hem l value'ya
hem r value'ya baÄŸlanÄ±yor. Bu durum iÃ§in kullanÄ±lan popÃ¼ler terim " Fallback ".

* Ã–yle durumlar var ki, aslÄ±nda koda bakarak hem biz aynÄ± zamanda derleyici, bir sÄ±nÄ±f nesnesinin artÄ±k kullanÄ±lma
olanaÄŸÄ±nÄ±n olmadÄ±ÄŸÄ±nÄ±,o nesneyi kullanacak bir kodun sÃ¶z konusu olmadÄ±ÄŸÄ±nÄ± anlayabiliyor(uz). BÃ¶yle bir durumda
bir sÄ±nÄ±f nesnesi varken onun deÄŸeriyle baÅŸka bir sÄ±nÄ±f nesnesini hayata getirmek istediÄŸimizde ÅŸimdiye kadar (Modern
C++'dan Ã¶nce) deÄŸerini alacaÄŸÄ±mÄ±z sÄ±nÄ±f nesnesinin hayatÄ±nÄ±n bitecek olmasÄ±na karÅŸÄ±n onun kaynaÄŸÄ±nÄ± yine kopyalÄ±yorduk
bir Ã§ok durumda.





______________________________________________________
	
	Move Constructor / Move Assignment
______________________________________________________



Move constructor ve move assignment Ã¶yle fonksiyonlar ki copy constructor ve copy assignmenta gÃ¶re, yaptÄ±klarÄ± iÅŸ
kopyalama yapmamak (deep copy yapmamak), diÄŸer nesnenin kaynaÄŸÄ±nÄ± Ã§almak ve sadece kaynaÄŸÄ±nÄ± Ã§almakla yetinmeyip 
diÄŸer nesne iÃ§in destructor Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda kaynaÄŸÄ± geri vermemesini saÄŸlamak.

Peki bunu nasÄ±l yapacaÄŸÄ±z?

BaÅŸka bir kodun kullanma ihtimali olmayan, hayatÄ± bitecek, gidici nesneler dilin kurallarÄ±na gÃ¶re bu ifadeler
saÄŸ taraf deÄŸeri. O zaman 2 tane constructor overloadu olsa biri sol taraf deÄŸeri argÃ¼manlar alsa, diÄŸeri saÄŸ taraf
deÄŸeri argÃ¼manlar alsa, saÄŸ taraf deÄŸeri argÃ¼manÄ± alan overload bilecek ki referansÄ±n baÄŸlandÄ±ÄŸÄ± nesnenin hayatÄ±nÄ±n
biteceÄŸi ve baÅŸka bir kodun ona ihtiyaÃ§ duymadÄ±ÄŸÄ±nÄ± bilecek ve onun kaynaÄŸÄ±nÄ± Ã§alacak. 

Derleyicinin yazdÄ±ÄŸÄ± move constructor, ismi sÄ±nÄ±fÄ±n ismi ile aynÄ± (constructor olduÄŸu iÃ§in) fakat parametresi
Myclass&& (sÄ±nÄ±f tÃ¼rÃ¼nden saÄŸ taraf referansÄ±).

	class Myclass{
	public:
		Myclass(const Myclass&);	// copy ctor
		Myclass (Myclass &&);		// move ctor // bunlar gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ Ã¼zere overload

		Myclass& operator=(const Myclass&);	// burada bir kopyalama yapÄ±lacak
		Myclass& operator=(Myclass&&);		// burada kaynak Ã§alÄ±nacak. bunlar da overload.
							// iÅŸte bu kaynak Ã§almaya move(taÅŸÄ±ma) diyoruz.
	};

* TaÅŸÄ±ma semantiÄŸi aslÄ±nda hiÃ§bir kopyalama yapÄ±lmayacak durumlarda  gereksiz yere kopyalama yapÄ±lmasÄ±nÄ±n Ã¶nÃ¼ne geÃ§er. Kopyalama maliyeti olaÄŸanÃ¼stÃ¼ yÃ¼ksek
olabilir bazÄ± durumlarda.

* Derleyicinin yazdÄ±ÄŸÄ± move constructor, elemanlara taÅŸÄ±ma yapÄ±yor kopyalama yapmÄ±yor. yani elemanlarÄ± da move constructor ile hayata getirecek.


// en sÄ±k yapÄ±lan hata -> Myclass(Myclass &&r) : ax(r.ax), bx(r.bx), cv(r.cx) {} // r saÄŸ taraf referansÄ± olsa da ifade r.ax ve diÄŸer ifadeler isim olduÄŸundan
dolayÄ± L value bir ifade oluÅŸturur. Bu ÅŸekilde yazarsak sÄ±k yapÄ±lan hataya bizde dÃ¼ÅŸmÃ¼ÅŸ oluruz. Bunun yerine r value ifadesi oluÅŸturan std::move() fonksiyonunu
kullanmalÄ±yÄ±z.


	class Myclass{
	public:
		////
		Myclass(const Myclass& r) : ax(r.ax), bx(r.bx), cx(r.cx) {}
		Myclass(Myclass &&r) : ax(std::move(r.ax)), bx(std::move(r.bx)), cv(std::move(r.cx)) {}

	private:
		A ax;
		B bx;
		C cx;
	};


SÄ±nÄ±fÄ±n move copy contstructorun derleyici tarafÄ±ndan yazÄ±lmasÄ±, eÄŸer sÄ±nÄ±fÄ±n elemanlarÄ± veya elemanlarÄ±ndan birisi handle ise felakete neden olur. Ama
sÄ±nÄ±fÄ±n move constructorunun olmasÄ± gerekirken olmamasÄ± bir felaket senaryosu deÄŸil. Sadece efficiency aÃ§Ä±sÄ±ndan zararÄ± var.

Yani move constructoru olmasa taÅŸÄ±manÄ±n faydalarÄ±ndan yararlanabileceÄŸimiz bir yararlanamaz ve kopyalama iÅŸlemi yapardÄ±k. Move constructorun ve move assignment'in
varlÄ±ÄŸÄ± bir hata durumunu engellemekten ziyade daha verimli hale getirmek, gereksiz kopyalamalardan kaÃ§Ä±nmaktÄ±r*. Gereksiz kopyalama yerine kopyalamayÄ±
ortadan kaldÄ±rÄ±p kaynaÄŸÄ±n bir nesneden adeta bir nesneye geÃ§mesini saÄŸlamak.

String sÄ±nÄ±fÄ±mÄ±z iÃ§in bir move constructor yazalÄ±m.



	class Myclass{
	public:
	String(const String& other) : mlen(other.mlen)
	{
		mp = static_cast<char*>(std::malloc(mlen+1));
		if (!mp) {
			std::cerr << "cannot allocate memory\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);	
	}

	String(String && other) : mlen(other.mlen), mp(other.mp)
	{
		other.mp = nllptr; // deÄŸerini Ã§aldÄ±ÄŸÄ±mÄ±z nesnenin pointeri hala bizim aldÄ±ÄŸÄ±mÄ±z adresi gÃ¶steriyor. destructor ile bizim adresin silinmemesini
			     	   // saÄŸlamak iÃ§in mp pointerini nullptr yaptÄ±k.
		other.mlen = 0;	   // bu da gerekli.
	}

	String& operator=(const String& other)
	{
		if(this == &other) // self assignment
			return *this;
		mlen = other.mlen;
		std::free(mp);

		mp = static_cast<char*>(std::malloc(mlen+1));
		if (!mp) {
			std::cerr << "cannot allocate memory\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);

		return *this;
	}

	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen+1));
		if (!mp) {
			std::cerr << "cannot allocate memory\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);
	}
	
	~String()
	{
		if (mp)
			std::free(mp);
	}

	std::size_t length()const
	{
		return mlen;
	}
	
	void print()const
	{
		std::cout << '[' << mp << "]\n";
	}	

	private:
	std::size_t mlen;
	char* mp;

	};


	
	int main()
	{
		String str(String{"bugun yine cok sicak bir hava vardi."}) // bu bir temp. obj. yani R value expr. o zaman move ctor Ã§aÄŸÄ±rÄ±lacak.
					//move ctor da bunun kaynaÄŸÄ±nÄ± kopyalamak yerine onu Ã§alacak.
	}


* SÄ±nÄ±fÄ±n hem copy cotr hem move cotr varsa bizim bunlardan hangisinin Ã§aÄŸÄ±rÄ±lmasÄ± gerektiÄŸini dÃ¼ÅŸÃ¼nmemiz gerekmiyor. GÃ¶nderdiÄŸimiz argÃ¼man L value ise
derleyici copy cotr seÃ§ecek, R value ise move cotr seÃ§ecek.

mÃ¼lakat sorusu
--------------

class Myclass{};

void func(Myclass &&)
{

}

int main()
{
	Myclass m;

	func(std::move(m)); // *
	//
}

Soru * iÅŸaretli satÄ±rdan sonra m nesnesinin kaynaÄŸÄ± Ã§alÄ±nmÄ±ÅŸ mÄ±dÄ±r?
-Cevap = HayÄ±r.

Bir nesneyi saÄŸ taraf referansÄ±na baÄŸlamak onun kaynaÄŸÄ±nÄ± Ã§almak demek deÄŸil.AslÄ±nda assembly kodunda gÃ¶receÄŸimiz ÅŸey func'Ä±n parametresi bir pointer ve
myclass nesnesinin adresini alÄ±yor. Peki kaynaÄŸÄ±n Ã§alÄ±nmasÄ±nÄ± saÄŸlayan ne olacak? - func iÃ§indeki implementasyon.

func iÃ§inde Ã¶yle bir implementasyon olmalÄ± ki bu saÄŸ taraf referansÄ±nÄ±n baÄŸlandÄ±ÄŸÄ± nesnenin kaynaÄŸÄ±nÄ± Ã§almalÄ±. Onunda 2 tane yolu var; ya bir myclass nesnesini
hayata getireceÄŸiz ya da bir myclass nesnesine atama yapacaÄŸÄ±z.
	
	class Myclass{};

	void func(Myclass && r)
	{
		Myclass mx = r; // r ifadesi L value. o halde bu nesne iÃ§in copy cotr Ã§aÄŸÄ±rÄ±lacak, move deÄŸil. o zaman kaynaÄŸÄ± Ã§almayacak, kopyalayacak.
				// kaynaÄŸÄ± Ã§almasÄ± iÃ§in burada ki mx'i hayata getirirken kullandÄ±ÄŸÄ±mÄ±z nesnenin r val. expr. olmasÄ± gerekir. peki nasÄ±l
				// yapacaÄŸÄ±z? - std::move() ile. Yani sorunun cevabÄ±nÄ±n evet olabilmesi iÃ§in bu kodun; Myclass mx = std::move(r); olmasÄ± lazÄ±m.
	}

	int main()
	{
		Myclass m;
	
		func(std::move(m));
		//
	}


///////////////////////////////

* En Ã§ok kullanÄ±lan yapÄ±lardan birisi;
L value ve R valueler iÃ§in ayrÄ± fonksiyon yazmak. L value iÃ§in yazÄ±lan fonksiyonun bir kopyalama yapmasÄ±nÄ± saÄŸlamak ama R value alan fonksiyonun kopyalama
yerine taÅŸÄ±ma yapmasÄ±nÄ± saÄŸlamak.


	class Myclass{};

	void func(Myclass && r)
	{
		Myclass mx = std::move(r);
	}
	
	void func(const Myclass& r)
	{
		Myclass mx = r;
	}



 * Bir saÄŸ taraf nesneyi saÄŸ taraf referansÄ±na baÄŸlayarak taÅŸÄ±ma semantiÄŸinden faydalanmÄ±ÅŸ olmuyoruz. Sadece taÅŸÄ±ma semantiÄŸine zemin hazÄ±rlamÄ±ÅŸ oluyoruz.
TaÅŸÄ±mayÄ± gerÃ§ekleÅŸtiren, burada bu referansÄ±n baÄŸlandÄ±ÄŸÄ± nesneyi kullanarak yeni bir nesne oluÅŸturmak. Veya varolan bir nesneye atama yapmak.

* Move constructorun implemente edilmesi iÃ§in bir fayda saÄŸlamasÄ± gerekiyor.


	class Myclass{
	private:
		int ar[1000];

	};

Ã–rneÄŸin yukarda move cotr ile yapabileceÄŸimiz birÅŸey yok. Ã‡Ã¼nkÃ¼ elimizde bir ptr yok ki kaynaÄŸÄ±nÄ± Ã§alalÄ±m. Fakat aÅŸaÄŸÄ±daki koda bakarsak;

	class Myclass{
	private:
		std::string* p;
	};

Ã–rnek olarak bu ptr dinamik olarak allocate edilmiÅŸ bir bellek bloÄŸundaki string nesnelerinin bulunduÄŸu bir bloÄŸun adresini tutuyor olsaydÄ±, burada move cotr
hayati Ã¶nem taÅŸÄ±rdÄ±. Ã‡Ã¼nkÃ¼ kopyalama semantiÄŸi ile yetinirsek, kopyalama yoluyla hayata getireceÄŸimiz nesne gidecek ayrÄ± bir bellek alanÄ± allocate edecek
ve Ã¼stelik orada string nesnelerini oluÅŸturacak. Yani diÄŸerinin allocate ettiÄŸi bellek bloÄŸunda 10000 tane string nesnesi varsa, bizim hayata getirdiÄŸimiz
string nesnesi de o 10000 tane string nesnesini hayata getirecek. Yani burada inanÄ±lmaz yÃ¼ksek bir maliyet sÃ¶z konusu olabilir.



	Move Assignment
--------------------------------

Bir sÄ±nÄ±f nesnesi bir sÄ±nÄ±f nesnesine bir R value expr. sÄ±nÄ±f nesnesini atadÄ±ÄŸÄ±mÄ±zda, aslÄ±nda atama op. saÄŸ tarafÄ±ndaki nesnenin artÄ±k bir daha kullanÄ±lmayacaÄŸÄ±nÄ±
biliyor olsak da, eÄŸer move assignment dediÄŸimiz fonksiyon olmasaydÄ± orada kopyalama yapmaya zorlamÄ±ÅŸ olacaktÄ±k.

	class Myclass{
		Myclass(const Myclass& r) : ax(r.ax), bx(r.bx), cx(r.cx) {}					// cctor
		Myclass(Myclass &&r) : ax(std::move(r.ax)), bx(std::move(r.bx)), cx(std::move(r.cx)) {}		// move ctor
		Myclass& operator=(const Myclass& r)
		{
			ax = r.ax;
			bx = r.bx;
			cx = r.cx;
			return *this;
		}
		
		Myclass& operator=(Myclass&& r)
		{
			ax = std::move(r.ax);
			bx = std::move(r.bx);
			cx = std::move(r.cx);
			return *this;		
		}

		private:
			A ax;
			B bx;
			C cx;
	};



----------------------------------------------------


	class Myclass{
	public:
	String(const String& other) : mlen(other.mlen)
	{
		mp = static_cast<char*>(std::malloc(mlen+1));
		if (!mp) {
			std::cerr << "cannot allocate memory\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);	
	}

	String(String && other) : mlen(other.mlen), mp(other.mp)
	{
		other.mp = nllptr; // deÄŸerini Ã§aldÄ±ÄŸÄ±mÄ±z nesnenin pointeri hala bizim aldÄ±ÄŸÄ±mÄ±z adresi gÃ¶steriyor. destructor ile bizim adresin silinmemesini
			     	   // saÄŸlamak iÃ§in mp pointerini nullptr yaptÄ±k.
		other.mlen = 0;	   // bu da gerekli.
	}

	String& operator=(const String& other)
	{
		if(this == &other) // self assignment
			return *this;
		mlen = other.mlen;
		std::free(mp);

		mp = static_cast<char*>(std::malloc(mlen+1));
		if (!mp) {
			std::cerr << "cannot allocate memory\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);

		return *this;
	}
	
	String& operator=(String&& other) 	// move assignment
	{
		if (this == &other)	// self-assignment kontrolÃ¼
			return *this;

		std::free(mp);		// bunu yazmasak kaynak sÄ±zÄ±ntÄ±sÄ± olur
		mlen = other.mlen;
		mp = other.mp;
		// kaynak Ã§alma kÄ±smÄ± tamamlandÄ±, ÅŸimdi diÄŸer nesnesyi destroyable bir state sokalÄ±m;
		other.mp = nullptr;
		other.mlen = 0;
	
		return *this;
	}
	
	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen+1));
		if (!mp) {
			std::cerr << "cannot allocate memory\n";
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);
	}
	
	~String()
	{
		if (mp)
			std::free(mp);
	}

	std::size_t length()const
	{
		return mlen;
	}
	
	void print()const
	{
		std::cout << '[' << mp << "]\n";
	}	

	private:
	std::size_t mlen;
	char* mp;

	};

-----------------------------------------

Elimizde bir L val. kategorisinde bir sÄ±nÄ±f nesnesi olmasÄ±na raÄŸmen yine de onun kaynaÄŸÄ±nÄ± Ã§almak istiyoruz. 

int main()
{
	std::string str(10000, 'A');
	
	std::string sx = str;	// burada sx iÃ§in cotr Ã§aÄŸÄ±rÄ±lÄ±r.

// Ã¶yle bir senaryo olsun ki, str'nin hayatÄ±nÄ±n devam ettiÄŸini biliyorum fakat str'yi artÄ±k kullanmayacaÄŸÄ±m dolayÄ±sÄ±yla sx'in str'nin kaynaÄŸÄ±nÄ±
kopyalamasÄ±nÄ± deÄŸil Ã§almasÄ±nÄ± istiyorum. std::move() ile bunu yapabiliriz.

	std::string sx = strstd::move(str);
	// str'nin kaynaÄŸÄ±nÄ± Ã§aldÄ±k
	
	//moved-from state/object deniyor. Yani nesne hala hayatta fakat kaynaÄŸÄ± Ã§alÄ±nmÄ±ÅŸ.
}


Bu durumda ÅŸu soruyu sormamÄ±z gerekiyor: Herhangi bir problem olmamasÄ± iÃ§in bÃ¶yle durumlarda neler yapabiliriz?
					 ----------------------------------------------------------------------

1.ihtimal ÅŸu olabilir: artÄ±k str'yi hiÃ§ kullanmayÄ±z. Yani str'nin kaynaÄŸÄ± Ã§alÄ±nmÄ±ÅŸtÄ±r ve ne zaman str'nin destructoru Ã§aÄŸÄ±rÄ±lacak olsa herhangi
bir sorun olmayacak Ã§Ã¼nkÃ¼ onun move cotr ona gÃ¶re yazÄ±lmÄ±ÅŸ. Peki biz str'yi kullanabilir miyiz? 
- Standard kÃ¼tÃ¼phanenin tÃ¼rleri (std::string, std::vector gibi vs.) ve 3.party kÃ¼tÃ¼phanelerin sÄ±nÄ±flarÄ± (eÄŸer Ã¶zel bir durum yoksa) sÄ±nÄ±flarÄ± 
kaynaÄŸÄ± Ã§alÄ±nmÄ±ÅŸ nesneler iÃ§in tipik olarak ÅŸu garantiyi veriyor;

	a) kaynaÄŸÄ± Ã§alÄ±nmÄ±ÅŸ nesne "in a valid state"
		Bu ne demek? bir nesnenin valid state'de olmasÄ± ne demek?
			-SÄ±nÄ±fÄ±n Invariant'larÄ± korunmuÅŸ olacak, bozulmayacak. 

	b) nesne destructible. ( destructor'un Ã§aÄŸÄ±rÄ±lmasÄ± herhangi bir soruna yol aÃ§mayacak. )
	
Ancak nesnenin deÄŸeri garanti altÄ±nda deÄŸil.

Ã–rneÄŸin string std kÃ¼tÃ¼phanenin string sÄ±nÄ±fÄ± iÃ§in biz bir string nesnesinin kaynaÄŸÄ±nÄ± Ã§alsak ve kaynaÄŸÄ± Ã§alÄ±nmÄ±ÅŸ nesnenin tuttuÄŸu yazÄ±yÄ± bir
ÅŸekilde yazdÄ±rsak ve o yazi "fatih"  yazÄ±sÄ± olsa(halen fatih yazÄ±sÄ±nÄ± tutuyor). SÄ±nÄ±fÄ±n length fonksiyonu string sÄ±nÄ±fÄ± nesnesinin tuttuÄŸu 
yazÄ±nÄ±n uzunluÄŸunu dÃ¶ndÃ¼rÃ¼yor. Bu durumda length fonksiyonunun 5 deÄŸerini dÃ¶ndÃ¼rmesi garanti altÄ±nda mÄ±?
- Evet garanti altÄ±nda. Valid state olmasÄ± bu demek. Yani sÄ±nÄ±f nesnesinin Ã¼ye fonksiyonlarÄ± Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda herhangi bir ÅŸekilde problem yok ama
deÄŸerinin ne olduÄŸunu bilmiyoruz.

InvariantlarÄ± tutmasÄ± demek: uzunluk deÄŸeri gerÃ§ekten uzunluk deÄŸeri, Ã¶rneÄŸin string'in tuttuÄŸu boÅŸ yazÄ± ise uzunluk deÄŸeri 0.

	c) nesneye yeni bir deÄŸer atayarak onu tekrar kullanabiliriz.


* moved from state'de ki nesnenin deÄŸerinin ne olacaÄŸÄ± derleyiciye baÄŸlÄ± ancak nesne geÃ§erli bir durumda. Yani o deÄŸeri kullanabiliriz. Bu deÄŸeri
kullanmak bir tanÄ±msÄ±z davranÄ±ÅŸ deÄŸil!***.




valid state'den ne kast ediliyor?
---------------------------------

int main()
{
	using namespace std;
	
	string str{"string yazisi"};
	
	auto s = move(str);

	cout << str.length() << "\n";		// 0

	if(str.empty())				// buraya girme garantisi var.
		cout << "evet bos yazi\n";

	cout << "(" << str << ")\n";		// parantezin iÃ§inde hiÃ§bir karakter olmayacaÄŸÄ± garantisi var.

	str = "string test";			// herhangi bir UB durumu yok.

}	// programÄ±n akÄ±ÅŸÄ± bu noktaya str iÃ§in destructor Ã§aÄŸÄ±rÄ±lacak mÄ±? - evet. Herhangi bir soruna yol aÃ§acak mÄ±? - hayÄ±r.


BÃ¼tÃ¼n sÄ±nÄ±flar bu garantileri vermek zorunda deÄŸil fakat standardda bÃ¶yle.




* SÄ±nÄ±f nesnelerinin ctor ya da copy assignment'i varsa yani sÄ±nÄ±f nesnelerinin kopyalanmasÄ±nda herhangi bir problem yoksa, bÃ¶yle sÄ±nÄ±flara
copyable sÄ±nÄ±flar diyebiliriz. Yani kopyalanmasÄ±nda herhangi bir engel yok. 

Ancak bazÄ± durumlarda biz sÄ±nÄ±f nesnelerinin kopyalanmasÄ±nÄ± engellemek istiyoruz. Nedeni de kopyalamanÄ±n semantik karÅŸÄ±lÄ±ÄŸÄ±nÄ±n olmamasÄ±. Yani
Ã¶yle sÄ±nÄ±flar var ki problem domainindeki temsil ettikleri kavram iÃ§in zaten kopyalama ya bir anlam taÅŸÄ±mÄ±yor, ya saÃ§ma ya da problemli.

Ã–rneÄŸin bir dosyayÄ± kontrol eden sÄ±nÄ±f nesnesi dÃ¼ÅŸÃ¼nelim. Bu nesnenin kopyasÄ±nÄ±n Ã§Ä±karÄ±lmasÄ± anlamsÄ±zdÄ±r. Ä°ÅŸte bÃ¶yle durumlarda sÄ±nÄ±f iÃ§in
kopyalama kapatÄ±lÄ±p sentaks hatasÄ± haline getiriliyor. Bunu yapmanÄ±n da yolu sÄ±nÄ±fÄ±n kopyalama Ã¶zel fonksiyonlarÄ±nÄ± delete etmek.

	class Nec{
	public:
		//..
		Nec();
		Nec(const Nec&) = delete;		// ctor delete bildirimi
		Nec& operator=(const Nec&) = delete;	// copy assignment delete bildirimi
	};

	int main()
	{
		Nec x;
	
		Nec y(x); // sentaks hatasÄ±

		Nec y;

		x = y;	// sentaks hatasÄ±
	}


BÃ¶yle sÄ±nÄ±flardan bahsederken, yani kopyalamaya karÅŸÄ± kapatÄ±lmÄ±ÅŸ sÄ±nÄ±flardan bahsederken onlara "non-copyable" sÄ±nÄ±flar diyoruz.
Ã–rneÄŸin standard kÃ¼tÃ¼phanede belirli fonksiyonlar non-copyable.

Fakat Ã¶yle sÄ±nÄ±flar var ki bu sÄ±nÄ±flar tÃ¼rÃ¼nden nesnelerin kopyalanmasÄ± istenmiyor ancak taÅŸÄ±ma semantiÄŸine aÃ§Ä±k olmasÄ± isteniyor. Bunlara da
popÃ¼ler olarak "move-only class" deniyor. KopyalamasÄ± yok fakat taÅŸÄ±masÄ± var.


------------------------------------------------------------------------------------------------------------------------------------------------

Derleyicilerin hangi durumlarda hangi special memberi implicitly declare edeceÄŸini Ã¶ÄŸrenelim. Bunun iÃ§in dilin kurallarÄ± devreye giriyor. Yani
derleyiciye/implementasyona baÄŸlÄ± deÄŸil direk dilin kuralÄ± olarak sabit.


1) EÄŸer sadece bÃ¶yle bir bildirim yaparsak;
	class Myclass{
	
	};

  Derleyici tarafÄ±ndan aÅŸaÄŸÄ±daki ÅŸekilde special member functionlar declare edilir.

	class Myclass{
	
	Myclass() = default;	
	~Myclass() = default;
	Myclass(const Myclass&) = default;
	Myclass(Myclass&&) = default;
	Myclass& operator=(const Myclass&) = default;
	Myclass& operator=(Myclass&&) = default;

	};

2) EÄŸer sÄ±nÄ±fa special member function olmayan bir constructor koyarsak sadece ve sadece Myclass() = default; olmaz.

Buradan ÅŸu kuralÄ± tekrar edelim: SÄ±nÄ±fa herhangi bir fonksiyonu, special member function olsun veya olmasÄ±n, user declared yaptÄ±ÄŸÄ±mÄ±z zaman
derleyici default ctor'u implicitly declare etmez. AÅŸaÄŸÄ±da da Ã¶rneÄŸi var.

	class Myclass{
		Myclass(int);
	};

	class Myclass{
	public:
		~Myclass() = default;
		Myclass(const Myclass&) = default;
		Myclass(Myclass&&) = default;
		Myclass& operator=(const Myclass&) = default;
		Myclass& operator=(Myclass&&) = default;
	};


3) EÄŸer sÄ±nÄ±fa user declared default ctor bildirirsek bu durumda yine sÄ±nÄ±fÄ±n diÄŸer bÃ¼tÃ¼n Ã¶zel Ã¼ye fonksiyonlarÄ± derleyici tarafÄ±ndan default
ediliyor.

	class Myclass{
		Myclass();
	};
	


	class Myclass{
		public:
		Myclass();
		~Myclass() = default;
		Myclass(const Myclass&) = default;
		Myclass(Myclass&&) = default;
		Myclass& operator=(const Myclass&) = default;
		Myclass& operator=(Myclass&&) = default;

	};
	

4) EÄŸer sÄ±nÄ±fa destructor bildirirsek, destructoru user-declared yapmÄ±ÅŸ oluruz fakat diÄŸer Ã¼ye fonksiyonlarÄ±n derleyici tarafÄ±ndan yazÄ±lmasÄ±nda
herhangi bir ÅŸekilde engel yok.

// dikkat bu durumda sÄ±nÄ±fÄ±n move memberlarÄ± yok. delete edilmiÅŸ deÄŸil, direk yok.

	class Myclass{
		~Myclass();
	};

	class Myclass{
		public:
		Myclass();
		~Myclass() = default;
		Myclass(const Myclass&) = default; 		// ?
		Myclass& operator=(const Myclass&) = default;   // ?

	};

*kritik -> User defined destructor bildirdiÄŸimiz zaman, derleyici sÄ±nÄ±fÄ±n move memberlarÄ±nÄ± default etmiyor. Yani move memberlar yok.
*kritik -> derleyici defult ctor'u default ediyor, copy ctor'u ve copy assignmenti yine default ediyor. Fakat bu durum son derece tehlikeli. Asla
ve asla bÃ¶yle bir duruma yol aÃ§mamamÄ±z gerekiyor. Ve standarda gÃ¶re bu deprecated ilan edildi.


4) Copy ctor bildirilmiÅŸse; default ctor yok, destructor var default, copy assignment var ve default, move ctor ve move assignment yok.
	
	class Myclass{
		Myclass(const Myclass&);  // copy ctor
	};
	
	class Myclass{
	public:
		~Myclass() = default;
		Myclass(const Myclass&);
		Myclass& operator=(const Myclass&) = default; //!!!
	};




5) Copy assignment bildirilmiÅŸse; default ctor var ve default , destructor var ve default, copy ctor var ve default, move ctor yok, move 
assignment yok.

	class Myclass{
		Myclass& operator=(const Myclass&);	// copy assignment	
	};
	
	class Myclass{
	public:
		Myclass() = default;
		~Myclass() = default;
		Myclass(const Myclass&) = default;
		Myclass& operator=(const Myclass &);
	
	};


6) SÄ±nÄ±fa move ctor yazarsanÄ±z; default ctor yok ( Ã§Ã¼nkÃ¼ bu zaten bir ctor. neydi kural? bir tane ctor bildirirseniz derleyici default ctor'u 
bildirmez), destructor var ve default, copy ctor var ama delete edilmiÅŸ. SÄ±nÄ±fa move ctor bildirirseniz derleyici copy ctor'u delete ediyor.
Move ctor zaten user declared, move assignment yok.


	class Myclass{
		Myclass(Myclass &&);
	};
	
	class Myclass{
	public:
		~Myclass() = default;
		Myclass(const Myclass&) = delete;
		Myclass& operator=(const Myclass&) = delete;
		Myclass(Myclass&&);
	};




7) Move assinment yazarsak; default ctor var ve default, destructor var ve default, copy assignment deleted, copy ctor deleted, move ctor yok, move assignment user 
declared.


	class Myclass{
		Myclass& operator=(Myclass &&); // move assignment
	};

	class Myclass{
	public:
		Myclass() = default;
		~Myclass() = default;
		Myclass(const Myclass&) = delete;
		Myclass& operator=(const Myclass&) = delete;
		Myclass& operator=(Myclass &&);
	};



* Bir sÄ±nÄ±fa herhangi (default ctor olmayan) bir ctor bildirirsek derleyici default ctor'u bildirmez. (not declared)
* Bir sÄ±nÄ±fÄ±n her zaman destructor'Ä± vardÄ±r. Destructorun olmadÄ±ÄŸÄ± bir senaryo yok. Biz bildirirseniz user declared, bizim bildirmediÄŸimiz bÃ¼tÃ¼n
durumlarda implicitly declared. 
* Bir sÄ±nÄ±fa eskiden bÃ¼yÃ¼k 3'lÃ¼ (big 3) (destructor, copy assignment, copy ctor) denilen bunlardan hangisini bildirirsek bildirelim, derleyici 
move memberlarÄ± bildirmez. Bu durumda sÄ±nÄ±fÄ±n move memberlarÄ± yoktur.
* Bir sÄ±nÄ±fa move memberlardan birini bildirirseniz ister move ctor olsun ister move assignment olsun, derleyici copy memberlarÄ± delete eder.
